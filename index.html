<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Platformer — Full Expanded + Progressive + +1 Obstacle/Level + Skip for 10 Coins</title>
  <style>
    body { margin:0; background:#111; }
    canvas { display:block; }
    .hud { position:fixed; inset:0; pointer-events:none; }
    .stick-area, .btn { pointer-events:auto; touch-action:none; }

    .stick-area {
      position:fixed; bottom:16px; left:16px;
      width:120px; height:120px;
      border-radius:50%;
      background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
    }
    .stick-knob {
      position:absolute; left:50%; top:50%;
      width:40px; height:40px;
      border-radius:50%;
      background:#0af;
      transform:translate(-50%,-50%);
    }
    .btn {
      position:fixed; right:16px; bottom:16px;
      width:80px; height:80px;
      border-radius:50%;
      background:#fff;
      display:flex; align-items:center; justify-content:center;
      font-weight:bold; user-select:none;
    }
    .label {
      position:fixed; top:8px; left:50%;
      transform:translateX(-50%);
      color:#fff; font-family:sans-serif; font-size:18px;
      background:rgba(0,0,0,0.4);
      padding:6px 10px; border-radius:8px;
    }
    #skipBtn {
      position:fixed; top:60px; right:20px;
      background:#fff; border:none; padding:8px 12px; border-radius:6px;
      font-weight:bold; display:block; cursor:pointer;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud">
  <div class="label" id="levelLabel">Level 1 | Coins: 0</div>
  <div id="moveStick" class="stick-area"><div id="moveKnob" class="stick-knob"></div></div>
  <div id="jumpBtn" class="btn">Jump</div>
</div>

<button id="skipBtn">Skip Level (10 coins)</button>

<script>
/* ===== Canvas ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize(); window.addEventListener("resize", resize);

/* ===== Constants ===== */
const TILE = 32;
const GROUND_Y = 15 * TILE;

/* ===== Player ===== */
let coinTotal = 0;
let hasKey = false;
const player = {
  x: 64, y: GROUND_Y - 28, w: 24, h: 28,
  vx: 0, vy: 0, onGround: false, jumps: 0, face: 1,
  color: "#ffd166"
};

/* ===== Input ===== */
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

let moveVec = { x: 0 };
(function setupStick(){
  const area = document.getElementById("moveStick");
  const knob = document.getElementById("moveKnob");
  let active = false, startX = 0;
  area.addEventListener("touchstart", e => { active = true; startX = e.touches[0].clientX; });
  area.addEventListener("touchmove", e => {
    if (!active) return;
    const dx = e.touches[0].clientX - startX;
    const radius = area.clientWidth / 2 - 20;
    const nx = Math.max(-radius, Math.min(radius, dx));
    knob.style.left = `calc(50% + ${nx}px)`;
    moveVec.x = nx / radius;
  });
  area.addEventListener("touchend", () => { active = false; moveVec.x = 0; knob.style.left = "50%"; });
})();
document.getElementById("jumpBtn").addEventListener("touchstart", tryJump);
function tryJump(){
  if (player.jumps < 2) {
    player.vy = -520;
    player.onGround = false;
    player.jumps++;
  }
}

/* ===== Utils ===== */
function aabb(ax, ay, aw, ah, bx, by, bw, bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function onTopOf(ax, ay, aw, ah, bx, by, bw, bh){
  return aabb(ax, ay, aw, ah, bx,by,bw,bh) && ay + ah <= by + 10 && player.vy >= 0;
}
function makePRNG(seed){ let s = seed >>> 0; return function(){ s = (s * 1664525 + 1013904223) >>> 0; return (s & 0xffffffff) / 4294967296; }; }

/* ===== Invulnerability after death ===== */
let invulnerable = false;
let invulnTimer = 0;

/* ===== Level state ===== */
let levelIndex = 1;
let level = null;
const bullets = [];

/* ===== HUD ===== */
function setHUD(name){ document.getElementById("levelLabel").textContent = `${name} | Coins: ${coinTotal}`; }

/* ===== Skip level for 10 coins ===== */
const skipBtn = document.getElementById("skipBtn");
function updateSkipButton(){
  skipBtn.textContent = coinTotal >= 10 ? "Skip Level (10 coins)" : "Skip Level (need 10 coins)";
  skipBtn.style.opacity = coinTotal >= 10 ? "1" : "0.6";
}
skipBtn.addEventListener("click", () => {
  if (coinTotal >= 10){
    coinTotal -= 10;
    loadLevel(levelIndex + 1);
  } else {
    // not enough coins; no-op
  }
  setHUD(level.name);
  updateSkipButton();
});

/* ===== Safety buffer (one player cube from spawn) ===== */
function safePlaceRect(obj, startX = 64, startY = GROUND_Y - 28){
  const cube = Math.max(player.w, player.h);
  const dx = Math.abs((obj.x + obj.w / 2) - (startX + player.w / 2));
  const dy = Math.abs((obj.y + obj.h / 2) - (startY + player.h / 2));
  return dx > cube || dy > cube;
}
function pushHazardSafe(L, h){ if (safePlaceRect(h)) L.hazards.push(h); }
function pushEnemySafe(L, e){ if (safePlaceRect({ x:e.x, y:e.y, w:e.w || 24, h:e.h || 24 })) L.enemies.push(e); }
function pushBulletSafe(b){ if (safePlaceRect({ x:b.x, y:b.y, w:b.w || 6, h:b.h || 6 })) bullets.push(b); }

/* ===== Progressive difficulty + “+1 obstacle per level” ===== */
function difficultyFactor(i){
  const base = 1 + (i / 100);      // 1.0 → 2.0 over 100 levels
  const curve = 1 + Math.max(0, i - 50) / 200; // gentle late-game bump
  return base * curve;
}
function obstacleCount(i){
  // Level 1 = 2 obstacles, Level 2 = 3, ... cap at 24 to keep it playable
  return Math.min(2 + (i - 1), 24);
}

/* ===== Level base ===== */
function makeLevelBase(name){
  return {
    name,
    bg: "#222",
    dark: false,
    flashlight: false,
    lowGravity: false,
    friction: 1.0,
    conveyorZones: [],

    platforms: [],
    fallPlatforms: [],
    hazards: [],
    saws: [],
    pendulums: [],
    windZones: [],
    teleportPads: [],
    timedDoors: [],

    breakables: [],
    bouncePads: [],
    enemies: [],
    coins: [],
    door: null,
    key: null,

    boss: false,
    bossReward: 100,
    goal: { x: canvas.width - 160, y: GROUND_Y - 32, w: 100, h: 32 }
  };
}

/* ===== Generators per theme with scaling and +1 obstacle/level ===== */
function genTutorial(){
  const L = makeLevelBase("Level 1 - Tutorial");
  L.bg = "#254027";
  L.platforms.push({ x: 220, y: GROUND_Y - 80, w: 120, h: 12 });
  L.coins.push({ x: 240, y: GROUND_Y - 100, r: 10, collected: false });
  L.pendulums.push({ x: 420, y: GROUND_Y - 120, r: 22, angle: 0, speed: 1.6 });
  L.fallPlatforms.push({ x: 560, y: GROUND_Y - 160, w: 90, h: 12, timer: 0, fall: false, threshold: 1.8 });
  pushHazardSafe(L, { x: 480, y: GROUND_Y - 16, w: 80, h: 16 });
  return L;
}

function genGrasslands(i, rnd){
  const L = makeLevelBase(`Level ${i} - Grasslands`);
  const f = difficultyFactor(i);
  L.bg = "#254027";

  const steps = 2 + Math.floor(rnd() * 2);
  for (let s = 0; s < steps; s++){
    const px = 220 + Math.floor(rnd() * 520);
    const py = GROUND_Y - (80 + Math.floor(rnd() * 130));
    const pw = 80 + Math.floor(rnd() * 80);
    L.platforms.push({ x: px, y: py, w: pw, h: 12 });
    if (rnd() < 0.6) L.coins.push({ x: px + pw / 2, y: py - 30, r: 10, collected: false });
  }

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 4;
    if (type === 0){
      pushHazardSafe(L, { x: 300 + Math.floor(rnd() * 480), y: GROUND_Y - 16, w: Math.floor((60 + rnd() * 80) * f), h: 16 });
    } else if (type === 1){
      L.pendulums.push({ x: 380 + Math.floor(rnd() * 300), y: GROUND_Y - 140, r: Math.floor(18 + rnd() * 8), angle: 0, speed: 1.8 * f });
    } else if (type === 2){
      L.saws.push({ x: 360 + Math.floor(rnd() * 320), y: GROUND_Y - 50, r: Math.floor(12 + rnd() * 6), dir: (rnd() < 0.5 ? -1 : 1), minX: 320, maxX: 640, speed: 90 * f });
    } else {
      L.fallPlatforms.push({ x: 420 + Math.floor(rnd() * 280), y: GROUND_Y - 160, w: 80, h: 12, timer: 0, fall: false, threshold: Math.max(0.8, 1.8 / f) });
    }
  }

  const base = 300 + Math.floor(rnd() * 420);
  pushEnemySafe(L, { type: "patrol", x: base, y: GROUND_Y - 28, w: 24, h: 28, dir: rnd() < 0.5 ? -1 : 1, minX: base - 80, maxX: base + 120, speed: Math.floor((60 + rnd() * 40) * f) });

  return L;
}

function genCaves(i, rnd){
  const L = makeLevelBase(`Level ${i} - Caves`);
  const f = difficultyFactor(i);
  L.bg = "#1c1c1c"; L.dark = true; L.flashlight = true;

  const ledges = 3 + Math.floor(rnd() * 2);
  for (let k = 0; k < ledges; k++){
    const px = 160 + Math.floor(rnd() * 520);
    const py = GROUND_Y - (90 + Math.floor(rnd() * 180));
    const pw = 60 + Math.floor(rnd() * 100);
    L.platforms.push({ x: px, y: py, w: pw, h: 12 });
    if (rnd() < 0.5) L.breakables.push({ x: px + Math.floor(rnd() * pw * 0.6), y: py - 12, w: 40, h: 12, broken: false });
    if (rnd() < 0.6) L.coins.push({ x: px + pw / 2, y: py - 30, r: 10, collected: false });
  }

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 4;
    if (type === 0){
      pushHazardSafe(L, { x: 220 + Math.floor(rnd() * 540), y: GROUND_Y - 16, w: Math.floor((50 + rnd() * 70) * f), h: 16 });
    } else if (type === 1){
      pushHazardSafe(L, { x: 340 + Math.floor(rnd() * 260), y: GROUND_Y - 260 - Math.floor(rnd() * 40), w: Math.floor(80 * f), h: 10 });
    } else if (type === 2){
      L.timedDoors.push({ x: 520 + Math.floor(rnd() * 80), y: GROUND_Y - 180, w: 30 + Math.floor(rnd() * 20), h: 120 + Math.floor(rnd() * 40), t: 0, period: Math.max(1.4, 2.4 / (0.8 + f * 0.4)), open: false });
    } else {
      L.pendulums.push({ x: 420 + Math.floor(rnd() * 160), y: GROUND_Y - 170, r: 18, angle: 0, speed: 1.8 * f });
    }
  }

  const bats = 1 + Math.floor(rnd() * (1 + f));
  for (let b = 0; b < bats; b++){
    const bx = 220 + Math.floor(rnd() * 540);
    const by = GROUND_Y - (120 + Math.floor(rnd() * 180));
    pushEnemySafe(L, { type: "fly", x: bx, y: by, w: 22, h: 22, t: rnd() * 6, ampX: Math.floor(40 + rnd() * 30 * f), ampY: Math.floor(25 + rnd() * 20 * f), baseX: bx, baseY: by, speed: 1.5 + rnd() * (1.2 * f) });
  }
  return L;
}

function genSky(i, rnd){
  const L = makeLevelBase(`Level ${i} - Sky`);
  const f = difficultyFactor(i);
  L.bg = "#1b2a49";

  const steps = 4 + Math.floor(rnd() * 3);
  let px = 180, py = GROUND_Y - 120;
  for (let s = 0; s < steps; s++){
    const pw = 60 + Math.floor(rnd() * 50);
    L.platforms.push({ x: px, y: py, w: pw, h: 12 });
    if (rnd() < 0.7) L.coins.push({ x: px + pw / 2, y: py - 28, r: 10, collected: false });
    py -= 50 + Math.floor(rnd() * 60);
    px += 80 + Math.floor(rnd() * 90);
  }

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 4;
    if (type === 0){
      L.windZones.push({ x: 240 + Math.floor(rnd() * 300), y: GROUND_Y - 200 - Math.floor(rnd() * 80), w: 200 + Math.floor(rnd() * 120), h: 120 + Math.floor(rnd() * 80), strength: Math.floor(120 + 60 * f) * (rnd() < 0.5 ? -1 : 1) });
    } else if (type === 1){
      const tx = 300 + Math.floor(rnd() * 200), ty = GROUND_Y - 220 - Math.floor(rnd() * 100);
      const gx = 560 + Math.floor(rnd() * 220), gy = GROUND_Y - 260 - Math.floor(rnd() * 120);
      L.teleportPads.push({ x: tx, y: ty, w: 22, h: 22, toX: gx, toY: gy });
    } else if (type === 2){
      L.saws.push({ x: 280 + Math.floor(rnd() * 300), y: GROUND_Y - 60 - Math.floor(rnd() * 40), r: 14, dir: (rnd() < 0.5 ? -1 : 1), minX: 240, maxX: 640, speed: 110 * f });
    } else {
      L.pendulums.push({ x: 520 + Math.floor(rnd() * 160), y: GROUND_Y - 180 - Math.floor(rnd() * 60), r: 20, angle: 0, speed: 2.2 * f });
    }
  }
  return L;
}

function genLava(i, rnd){
  const L = makeLevelBase(`Level ${i} - Lava Fortress`);
  const f = difficultyFactor(i);
  L.bg = "#3b1e1e";

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 4;
    if (type === 0){
      pushHazardSafe(L, { x: 220 + Math.floor(rnd() * 540), y: GROUND_Y - 16, w: Math.floor((60 + rnd() * 90) * f), h: 16 });
    } else if (type === 1){
      L.fallPlatforms.push({ x: 360 + Math.floor(rnd() * 300), y: GROUND_Y - 60, w: 50, h: 10, timer: 0, fall: false, threshold: Math.max(0.6, 1.6 / f) });
    } else if (type === 2){
      L.saws.push({ x: 420 + Math.floor(rnd() * 300), y: GROUND_Y - 50, r: 16, dir: (rnd() < 0.5 ? -1 : 1), minX: 380, maxX: 720, speed: 120 * f });
    } else {
      L.pendulums.push({ x: 500 + Math.floor(rnd() * 220), y: GROUND_Y - 160, r: 18, angle: 0, speed: 1.9 * f });
    }
  }

  const chasers = 1 + Math.floor(rnd() * (1 + f));
  for (let c = 0; c < chasers; c++){
    const ex = 420 + Math.floor(rnd() * 300);
    pushEnemySafe(L, { type: "chase", x: ex, y: GROUND_Y - 28, w: 24, h: 28, speed: Math.floor((85 + rnd() * 40) * f), range: Math.floor(240 + rnd() * 120 * f) });
  }
  return L;
}

function genIce(i, rnd){
  const L = makeLevelBase(`Level ${i} - Ice Peaks`);
  const f = difficultyFactor(i);
  L.bg = "#173e43"; L.friction = 0.55;

  const shelves = 2 + Math.floor(rnd() * 3);
  for (let k = 0; k < shelves; k++){
    const px = 260 + Math.floor(rnd() * 420);
    const py = GROUND_Y - (100 + Math.floor(rnd() * 120));
    const pw = 90 + Math.floor(rnd() * 80);
    L.platforms.push({ x: px, y: py, w: pw, h: 12 });
    if (rnd() < 0.5) L.coins.push({ x: px + pw / 2, y: py - 26, r: 10, collected: false });
  }

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 3;
    if (type === 0){
      pushHazardSafe(L, { x: 320 + Math.floor(rnd() * 300), y: GROUND_Y - 16, w: Math.floor((60 + rnd() * 80) * f), h: 16 });
    } else if (type === 1){
      L.pendulums.push({ x: 480 + Math.floor(rnd() * 220), y: GROUND_Y - 180, r: 18, angle: 0, speed: 2.2 * f });
    } else {
      L.fallPlatforms.push({ x: 420 + Math.floor(rnd() * 280), y: GROUND_Y - 140, w: 80, h: 12, timer: 0, fall: false, threshold: Math.max(0.8, 1.7 / f) });
    }
  }

  pushEnemySafe(L, { type: "patrol", x: 360 + Math.floor(rnd() * 240), y: GROUND_Y - 28, w: 24, h: 28, dir: rnd() < 0.5 ? -1 : 1, minX: 300, maxX: 620, speed: Math.floor((60 + rnd() * 30) * f) });
  return L;
}

function genFactory(i, rnd){
  const L = makeLevelBase(`Level ${i} - Factory`);
  const f = difficultyFactor(i);
  L.bg = "#2c2c34";

  L.conveyorZones.push({ x: 200, y: GROUND_Y - 12, w: 160, h: 12, speed: 140 * f });
  L.conveyorZones.push({ x: 420, y: GROUND_Y - 12, w: 160, h: 12, speed: -140 * f });

  L.platforms.push({ x: 360 + Math.floor(rnd() * 140), y: GROUND_Y - 120 - Math.floor(rnd() * 40), w: 100, h: 12 });

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 3;
    if (type === 0){
      L.timedDoors.push({ x: 460 + Math.floor(rnd() * 180), y: GROUND_Y - 180, w: 30 + Math.floor(rnd() * 20), h: 140, t: 0, period: Math.max(1.2, 2.2 / (0.7 + f * 0.4)), open: false });
    } else if (type === 1){
      L.saws.push({ x: 320 + Math.floor(rnd() * 280), y: GROUND_Y - 60, r: 15, dir: (rnd() < 0.5 ? -1 : 1), minX: 300, maxX: 620, speed: 130 * f });
    } else {
      L.bouncePads.push({ x: 300 + Math.floor(rnd() * 360), y: GROUND_Y - 16, w: 50, h: 16, power: 900 + Math.floor(120 * f) });
    }
  }

  const turrets = 1 + Math.floor(rnd() * (1 + f));
  for (let t = 0; t < turrets; t++){
    pushEnemySafe(L, { type: "turret", x: 500 + Math.floor(rnd() * 120), y: GROUND_Y - 48 - Math.floor(rnd() * 60), w: 20, h: 20, fire: 0, rate: Math.max(0.5, 0.9 / (0.7 + f * 0.4)) });
  }
  return L;
}

function genHaunted(i, rnd){
  const L = makeLevelBase(`Level ${i} - Haunted Ruins`);
  const f = difficultyFactor(i);
  L.bg = "#252038"; L.dark = true; L.flashlight = true;

  L.platforms.push({ x: 240 + Math.floor(rnd() * 200), y: GROUND_Y - 120 - Math.floor(rnd() * 40), w: 100 + Math.floor(rnd() * 50), h: 12 });

  L.door = { x: 520 + Math.floor(rnd() * 40), y: GROUND_Y - 72, w: 24, h: 72 };
  L.key = { x: 260 + Math.floor(rnd() * 200), y: GROUND_Y - 132, w: 18, h: 18, collected: false };

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 3;
    if (type === 0){
      L.pendulums.push({ x: 420 + Math.floor(rnd() * 200), y: GROUND_Y - 170, r: 18, angle: 0, speed: 1.8 * f });
    } else if (type === 1){
      L.timedDoors.push({ x: 600 + Math.floor(rnd() * 120), y: GROUND_Y - 90, w: 30, h: 90, t: 0, period: Math.max(1.4, 3.0 / (0.7 + f * 0.4)), open: true });
    } else {
      pushHazardSafe(L, { x: 360 + Math.floor(rnd() * 240), y: GROUND_Y - 16, w: Math.floor((50 + rnd() * 70) * f), h: 16 });
    }
  }

  const ghosts = 1 + Math.floor(rnd() * (1 + f));
  for (let g = 0; g < ghosts; g++){
    pushEnemySafe(L, { type: "ghost", x: 400 + Math.floor(rnd() * 200), y: GROUND_Y - 28, w: 24, h: 28, t: rnd() * 3, visible: true });
  }
  return L;
}

function genJungle(i, rnd){
  const L = makeLevelBase(`Level ${i} - Jungle`);
  const f = difficultyFactor(i);
  L.bg = "#1f3a2d";

  L.platforms.push({ x: 220 + Math.floor(rnd() * 160), y: GROUND_Y - 110 - Math.floor(rnd() * 40), w: 90 + Math.floor(rnd() * 40), h: 12, vx: (rnd() < 0.5 ? 70 : -70) * f, vy: 0, minX: 180, maxX: 360 });
  L.platforms.push({ x: 420 + Math.floor(rnd() * 160), y: GROUND_Y - 190 - Math.floor(rnd() * 40), w: 90 + Math.floor(rnd() * 40), h: 12, vy: (rnd() < 0.5 ? 70 : -70) * f, minY: GROUND_Y - 250, maxY: GROUND_Y - 130 });

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 3;
    if (type === 0){
      L.pendulums.push({ x: 520 + Math.floor(rnd() * 180), y: GROUND_Y - 160, r: 22, angle: 0, speed: 1.9 * f });
    } else if (type === 1){
      L.fallPlatforms.push({ x: 580 + Math.floor(rnd() * 160), y: GROUND_Y - 120, w: 80, h: 12, timer: 0, fall: false, threshold: Math.max(0.7, 1.6 / f) });
    } else {
      pushHazardSafe(L, { x: 360 + Math.floor(rnd() * 240), y: GROUND_Y - 16, w: Math.floor((50 + rnd() * 70) * f), h: 16 });
    }
  }

  pushEnemySafe(L, { type: "patrol", x: 300 + Math.floor(rnd() * 160), y: GROUND_Y - 28, w: 24, h: 28, dir: 1, minX: 260, maxX: 360, speed: 70 * f });
  return L;
}

function genSpace(i, rnd){
  const L = makeLevelBase(`Level ${i} - Space`);
  const f = difficultyFactor(i);
  L.bg = "#0a0f1d"; L.lowGravity = true;

  L.platforms.push({ x: 260 + Math.floor(rnd() * 160), y: GROUND_Y - 160 - Math.floor(rnd() * 60), w: 90 + Math.floor(rnd() * 60), h: 12 });
  L.platforms.push({ x: 420 + Math.floor(rnd() * 160), y: GROUND_Y - 230 - Math.floor(rnd() * 60), w: 90 + Math.floor(rnd() * 60), h: 12 });

  const count = obstacleCount(i);
  for (let k = 0; k < count; k++){
    const type = k % 4;
    if (type === 0){
      pushHazardSafe(L, { x: 320 + Math.floor(rnd() * 180), y: GROUND_Y - 16, w: Math.floor((70 + rnd() * 80) * f), h: 16 });
    } else if (type === 1){
      L.teleportPads.push({ x: 340 + Math.floor(rnd() * 180), y: GROUND_Y - 140 - Math.floor(rnd() * 80), w: 22, h: 22, toX: 620 + Math.floor(rnd() * 100), toY: GROUND_Y - 260 - Math.floor(rnd() * 120) });
    } else if (type === 2){
      L.saws.push({ x: 380 + Math.floor(rnd() * 240), y: GROUND_Y - 90, r: 16, dir: (rnd() < 0.5 ? -1 : 1), minX: 340, maxX: 640, speed: 130 * f });
    } else {
      L.pendulums.push({ x: 520 + Math.floor(rnd() * 160), y: GROUND_Y - 200, r: 18, angle: 0, speed: 2.1 * f });
    }
  }

  pushEnemySafe(L, { type: "fly", x: 480 + Math.floor(rnd() * 100), y: GROUND_Y - 160 - Math.floor(rnd() * 60), w: 22, h: 22, t: rnd() * 6, ampX: Math.floor(60 * f), ampY: Math.floor(40 * f), baseX: 480, baseY: GROUND_Y - 160, speed: 1.2 + rnd() * 0.8 * f });
  L.coins.push({ x: 420 + Math.floor(rnd() * 160), y: GROUND_Y - 250 - Math.floor(rnd() * 40), r: 10, collected: false });
  return L;
}

function genBoss(i, rnd){
  const world = Math.floor((i - 1) / 10) + 1;
  const f = difficultyFactor(i);
  const L = makeLevelBase(`Level ${i} - Boss`);
  L.bg = "#2a1f1f"; L.boss = true; L.goal = null;

  const hp = Math.floor(6 * (1 + world * 0.15) * f);
  const rate = Math.max(0.4, (0.9 - 0.05 * world) / (0.7 + f * 0.4));
  pushEnemySafe(L, { type: "boss", x: 520, y: GROUND_Y - 80, w: 100, h: 100, hp, fire: 0, rate });

  const count = Math.min(3 + world, obstacleCount(i));
  for (let k = 0; k < count; k++){
    const type = (world + k) % 4;
    if (type === 0) pushHazardSafe(L, { x: 340 + Math.floor(rnd() * 220), y: GROUND_Y - 16, w: Math.floor(80 * f), h: 16 });
    else if (type === 1) L.pendulums.push({ x: 440 + Math.floor(rnd() * 180), y: GROUND_Y - 160, r: 20, angle: 0, speed: 2.0 * f });
    else if (type === 2) L.saws.push({ x: 360 + Math.floor(rnd() * 220), y: GROUND_Y - 60, r: 16, dir: (rnd() < 0.5 ? -1 : 1), minX: 340, maxX: 620, speed: 140 * f });
    else L.timedDoors.push({ x: 580 + Math.floor(rnd() * 120), y: GROUND_Y - 90, w: 30, h: 90, t: 0, period: Math.max(1.2, 2.0 / (0.7 + f * 0.4)), open: true });
  }

  return L;
}

/* ===== Level dispatcher ===== */
function generateLevel(i){
  const rnd = makePRNG(i * 98765 + 12345);
  if (i === 1) return genTutorial();
  if (i % 10 === 0) return genBoss(i, rnd);
  if (i <= 10) return genGrasslands(i, rnd);
  if (i <= 20) return genCaves(i, rnd);
  if (i <= 30) return genSky(i, rnd);
  if (i <= 40) return genLava(i, rnd);
  if (i <= 50) return genIce(i, rnd);
  if (i <= 60) return genFactory(i, rnd);
  if (i <= 70) return genHaunted(i, rnd);
  if (i <= 80) return genJungle(i, rnd);
  return genSpace(i, rnd); // 81–99
}

/* ===== Load/reset and death handling ===== */
function loadLevel(idx){
  levelIndex = ((idx - 1) % 100) + 1;
  level = generateLevel(levelIndex);
  hasKey = false;

  player.x = 64; player.y = GROUND_Y - 28;
  player.vx = 0; player.vy = 0;
  player.jumps = 0; player.onGround = false; player.face = 1;

  bullets.length = 0;
  setHUD(level.name);
  updateSkipButton();
}
function killPlayer(){
  loadLevel(levelIndex);
  invulnerable = true;
  invulnTimer = 1.0;
}
loadLevel(1);

/* ===== Update + physics ===== */
function update(dt){
  const L = level;
  const gravity = L.lowGravity ? 520 : 1000;
  const baseSpeed = 240;
  const friction = L.friction || 1.0;

  const left = keys["ArrowLeft"] || keys["KeyA"] || moveVec.x < -0.2;
  const right = keys["ArrowRight"] || keys["KeyD"] || moveVec.x > 0.2;
  if (left && !right){ player.vx = -baseSpeed * friction; player.face = -1; }
  else if (right && !left){ player.vx = baseSpeed * friction; player.face = 1; }
  else { player.vx *= 0.85 * friction; }

  if (keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) tryJump();

  player.vy += gravity * dt;

  // Conveyors
  for (const z of L.conveyorZones){
    if (onTopOf(player.x, player.y, player.w, player.h, z.x, z.y, z.w, z.h)) player.x += z.speed * dt;
  }

  // Wind zones
  for (const wz of L.windZones){
    if (aabb(player.x, player.y, player.w, player.h, wz.x, wz.y, wz.w, wz.h)) player.vx += Math.sign(wz.strength) * Math.abs(wz.strength) * dt;
  }

  // Movement
  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // Ground
  if (player.y + player.h > GROUND_Y){
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
    player.jumps = 0;
  } else {
    player.onGround = false;
  }

  // Platforms
  for (const p of L.platforms){
    if (p.vx){
      p.x += p.vx * dt;
      if (p.minX !== undefined && (p.x < p.minX || p.x > p.maxX)) p.vx *= -1;
    }
    if (p.vy){
      p.y += p.vy * dt;
      if (p.minY !== undefined && (p.y < p.minY || p.y > p.maxY)) p.vy *= -1;
    }
    if (onTopOf(player.x, player.y, player.w, player.h, p.x, p.y, p.w, p.h)){
      player.y = p.y - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumps = 0;
    }
  }

  // Falling platforms
  for (const fp of L.fallPlatforms){
    const threshold = fp.threshold ?? 1.8;
    if (!fp.fall && onTopOf(player.x, player.y, player.w, player.h, fp.x, fp.y, fp.w, fp.h)){
      fp.timer += dt;
      player.y = fp.y - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumps = 0;
      if (fp.timer >= threshold) fp.fall = true;
    }
    if (fp.fall) fp.y += 380 * dt;
  }

  // Bounce pads
  for (const b of L.bouncePads){
    if (onTopOf(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h)){
      player.vy = -b.power;
      player.onGround = false;
    }
  }

  // Breakables
  for (const br of L.breakables){
    if (!br.broken && onTopOf(player.x, player.y, player.w, player.h, br.x, br.y, br.w, br.h)){
      br.broken = true; player.onGround = false; player.vy = Math.max(player.vy, 50);
    }
  }

  // Timed doors update
  for (const td of L.timedDoors){
    td.t += dt;
    const phase = (td.t % td.period);
    td.open = phase < td.period / 2;
    if (!td.open && aabb(player.x, player.y, player.w, player.h, td.x, td.y, td.w, td.h)){
      if (player.x + player.w / 2 < td.x + td.w / 2) player.x = td.x - player.w;
      else player.x = td.x + td.w;
      player.vx = 0;
    }
  }

  // Pendulums
  for (const pend of L.pendulums){
    pend.angle += pend.speed * dt;
  }

  // Saws
  for (const s of L.saws){
    s.x += s.dir * s.speed * dt;
    if (s.x < s.minX){ s.x = s.minX; s.dir = 1; }
    if (s.x > s.maxX){ s.x = s.maxX; s.dir = -1; }
  }

  // Door/key
  if (L.key && !L.key.collected && aabb(player.x, player.y, player.w, player.h, L.key.x, L.key.y, L.key.w, L.key.h)){
    L.key.collected = true; hasKey = true;
  }
  if (L.door){
    if (aabb(player.x, player.y, player.w, player.h, L.door.x, L.door.y, L.door.w, L.door.h)){
      if (!hasKey){
        if (player.x + player.w / 2 < L.door.x + L.door.w / 2) player.x = L.door.x - player.w;
        else player.x = L.door.x + L.door.w;
        player.vx = 0;
      }
    }
  }

  // Invulnerability countdown
  if (invulnerable){
    invulnTimer -= dt;
    if (invulnTimer <= 0) invulnerable = false;
  }

  // Hazard collisions
  if (!invulnerable){
    for (const h of L.hazards){
      if (aabb(player.x, player.y, player.w, player.h, h.x, h.y, h.w, h.h)){ killPlayer(); return; }
    }
    for (const pend of L.pendulums){
      const bobX = pend.x + Math.sin(pend.angle) * 60;
      const bobY = pend.y + Math.cos(pend.angle) * 60;
      const px = Math.max(player.x, Math.min(bobX, player.x + player.w));
      const py = Math.max(player.y, Math.min(bobY, player.y + player.h));
      const dx = bobX - px, dy = bobY - py;
      if (dx*dx + dy*dy < pend.r * pend.r){ killPlayer(); return; }
    }
    for (const s of L.saws){
      const px = Math.max(player.x, Math.min(s.x, player.x + player.w));
      const py = Math.max(player.y, Math.min(s.y, player.y + player.h));
      const dx = s.x - px, dy = s.y - py;
      if (dx*dx + dy*dy < s.r * s.r){ killPlayer(); return; }
    }
  }

  // Coins
  for (const c of L.coins){
    if (!c.collected && aabb(player.x, player.y, player.w, player.h, c.x - c.r, c.y - c.r, c.r * 2, c.r * 2)){
      c.collected = true; coinTotal++; setHUD(L.name); updateSkipButton();
    }
  }

  // Enemies
  for (const e of L.enemies){
    if (e.type === "patrol"){
      e.x += e.dir * e.speed * dt;
      if (e.x < e.minX){ e.x = e.minX; e.dir *= -1; }
      if (e.x + e.w > e.maxX){ e.x = e.maxX - e.w; e.dir *= -1; }
    } else if (e.type === "fly"){
      e.t += e.speed * dt;
      e.x = e.baseX + Math.sin(e.t) * e.ampX;
      e.y = e.baseY + Math.cos(e.t * 0.9) * e.ampY;
    } else if (e.type === "chase"){
      const dx = player.x - e.x;
      if (Math.abs(dx) < e.range) e.x += Math.sign(dx) * e.speed * dt;
    } else if (e.type === "ghost"){
      e.t += dt; e.visible = Math.floor(e.t % 2) === 0;
    } else if (e.type === "turret"){
      e.fire = (e.fire || 0) + dt;
      if (e.fire >= (e.rate || 1)){
        e.fire = 0;
        const bx = e.x + e.w / 2, by = e.y + e.h / 2;
        const dx = (player.x + player.w / 2) - bx;
        const dy = (player.y + player.h / 2) - by;
        const len = Math.max(1, Math.hypot(dx, dy));
        const b = { x: bx, y: by, w: 6, h: 6, vx: (dx / len) * 270, vy: (dy / len) * 270, ttl: 4, color: "#ffcc00" };
        pushBulletSafe(b);
      }
    } else if (e.type === "boss"){
      e.fire = (e.fire || 0) + dt;
      if (e.fire >= (e.rate || 0.9)){
        e.fire = 0;
        const N = 8 + Math.floor(Math.random() * 4);
        for (let k = 0; k < N; k++){
          const ang = (k / N) * Math.PI * 2;
          const b = { x: e.x + e.w / 2, y: e.y + e.h / 2, w: 8, h: 8, vx: Math.cos(ang) * 230, vy: Math.sin(ang) * 230, ttl: 5, color: "#ff6666" };
          pushBulletSafe(b);
        }
      }
    }

    // Player collision with enemies
    if (!invulnerable){
      if (e.type === "ghost"){
        if (e.visible && aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)){ killPlayer(); return; }
      } else if (e.type === "boss"){
        const stomping = player.vy > 0 && player.y + player.h <= e.y + 12 && aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h);
        if (stomping){
          player.vy = -540;
          e.hp--;
          if (e.hp <= 0){ coinTotal += L.bossReward; setHUD(L.name); updateSkipButton(); loadLevel(levelIndex + 1); return; }
        } else if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)){
          killPlayer(); return;
        }
      } else {
        if (aabb(player.x, player.y, player.w, player.h, e.x, e.y, e.w, e.h)){ killPlayer(); return; }
      }
    }
  }

  // Bullets
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.ttl -= dt;
    if (!invulnerable && aabb(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h)){ killPlayer(); return; }
    if (b.ttl <= 0) bullets.splice(i, 1);
  }

  // Teleports
  for (const tp of L.teleportPads){
    if (aabb(player.x, player.y, player.w, player.h, tp.x, tp.y, tp.w, tp.h)){
      player.x = tp.toX; player.y = tp.toY;
    }
  }

  // Goal -> next level
  if (!L.boss && L.goal && aabb(player.x, player.y, player.w, player.h, L.goal.x, L.goal.y, L.goal.w, L.goal.h)){
    loadLevel(levelIndex + 1); return;
  }
}

/* ===== Draw ===== */
function draw(){
  const L = level;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Background
  ctx.fillStyle = L.bg;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Ground
  ctx.fillStyle = "#555";
  ctx.fillRect(0,GROUND_Y,canvas.width,4);

  // Hazards
  ctx.fillStyle = "#d84315";
  for (const h of L.hazards) ctx.fillRect(h.x, h.y, h.w, h.h);

  // Platforms
  ctx.fillStyle = "#90a4ae";
  for (const p of L.platforms) ctx.fillRect(p.x, p.y, p.w, p.h);

  // Falling platforms
  ctx.fillStyle = "#7da453";
  for (const fp of L.fallPlatforms) ctx.fillRect(fp.x, fp.y, fp.w, fp.h);

  // Bounce pads
  ctx.fillStyle = "#7cb342";
  for (const b of L.bouncePads) ctx.fillRect(b.x, b.y, b.w, b.h);

  // Breakables
  for (const br of L.breakables){
    ctx.fillStyle = br.broken ? "rgba(120,90,60,0.25)" : "#8d6e63";
    ctx.fillRect(br.x, br.y, br.w, br.h);
  }

  // Conveyor zones
  ctx.fillStyle = "rgba(200,200,255,0.22)";
  for (const z of L.conveyorZones) ctx.fillRect(z.x, z.y, z.w, z.h);

  // Timed doors
  for (const td of L.timedDoors){
    ctx.fillStyle = td.open ? "rgba(30,150,30,0.4)" : "#6d4c41";
    ctx.fillRect(td.x, td.y, td.w, td.h);
  }

  // Wind zones
  ctx.fillStyle = "rgba(100,160,255,0.14)";
  for (const wz of L.windZones) ctx.fillRect(wz.x, wz.y, wz.w, wz.h);

  // Teleport pads
  ctx.fillStyle = "#9ccc65";
  for (const tp of L.teleportPads) ctx.fillRect(tp.x, tp.y, tp.w, tp.h);

  // Door/key
  if (L.door){ ctx.fillStyle = hasKey ? "#4caf50" : "#6d4c41"; ctx.fillRect(L.door.x, L.door.y, L.door.w, L.door.h); }
  if (L.key && !L.key.collected){ ctx.fillStyle = "#cddc39"; ctx.fillRect(L.key.x, L.key.y, L.key.w, L.key.h); }

  // Goal
  if (!L.boss && L.goal){ ctx.fillStyle = "#1e88e5"; ctx.fillRect(L.goal.x, L.goal.y, L.goal.w, L.goal.h); }

  // Coins
  for (const c of L.coins){
    if (!c.collected){
      ctx.fillStyle = "#ffd700";
      ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, Math.PI*2); ctx.fill();
    }
  }

  // Pendulums
  for (const pend of L.pendulums){
    const bobX = pend.x + Math.sin(pend.angle) * 60;
    const bobY = pend.y + Math.cos(pend.angle) * 60;
    ctx.strokeStyle = "#aaa"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(pend.x, pend.y); ctx.lineTo(bobX, bobY); ctx.stroke();
    ctx.fillStyle = "#f06292";
    ctx.beginPath(); ctx.arc(bobX, bobY, pend.r, 0, Math.PI*2); ctx.fill();
  }

  // Saws
  for (const s of L.saws){
    ctx.fillStyle = "#b0bec5";
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#78909c"; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(s.x - s.r, s.y); ctx.lineTo(s.x + s.r, s.y); ctx.stroke();
  }

  // Enemies
  for (const e of L.enemies){
    let color = "#ff4444";
    if (e.type === "fly") color = "#ff8a65";
    if (e.type === "chase") color = "#f44336";
    if (e.type === "ghost") color = e.visible ? "#9c27b0" : "rgba(156,39,176,0.3)";
    if (e.type === "turret") color = "#b0bec5";
    if (e.type === "boss") color = "#e53935";
    ctx.fillStyle = color;
    ctx.fillRect(e.x, e.y, e.w, e.h);

    if (e.type === "boss"){
      ctx.fillStyle = "#222"; ctx.fillRect(e.x, e.y - 10, e.w, 6);
      const maxHp = Math.max(e.hp, 12);
      ctx.fillStyle = "#76ff03";
      ctx.fillRect(e.x, e.y - 10, (Math.max(0, e.hp) / maxHp) * e.w, 6);
    }
  }

  // Bullets
  for (const b of bullets){ ctx.fillStyle = b.color || "#fff"; ctx.fillRect(b.x, b.y, b.w, b.h); }

  // Player
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // Darkness + flashlight
  if (L.dark && L.flashlight){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.92)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const cx = player.x + player.w/2, cy = player.y + player.h/2;
    const angle = player.face === 1 ? 0 : Math.PI;
    const spread = Math.PI/4, radius = 240;
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, radius, angle - spread, angle + spread); ctx.closePath(); ctx.fill();
    const glowR = 110; const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.92)");
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, glowR, 0, Math.PI*2); ctx.fill(); ctx.restore();
  } else if (L.dark){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.85)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const cx = player.x + player.w/2, cy = player.y + player.h/2, r = 130;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
    grad.addColorStop(0, "rgba(0,0,0,0)"); grad.addColorStop(1, "rgba(0,0,0,0.85)");
    ctx.globalCompositeOperation = "destination-out";
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }

  // Invulnerability cue
  if (invulnerable){
    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(player.x - 2, player.y - 2, player.w + 4, player.h + 4);
    ctx.restore();
  }
}

/* ===== Loop ===== */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now - last) / 1000);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Cosmetic color switch ===== */
window.addEventListener("keydown", (e) => {
  if (e.code === "Digit1") player.color = "#ffd166";
  if (e.code === "Digit2") player.color = "#ff595e";
  if (e.code === "Digit3") player.color = "#8ac926";
  if (e.code === "Digit4") player.color = "#1982c4";
});
</script>
</body>
</html>
