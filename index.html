<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Progressive Platformer</title>
  <style>
    body { margin:0; background:#111; }
    canvas { display:block; }
    .hud { position:fixed; inset:0; pointer-events:none; }
    .stick-area, .btn { pointer-events:auto; touch-action:none; }
    .stick-area {
      position:fixed; bottom:16px; left:16px; width:120px; height:120px;
      border-radius:50%; background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
    }
    .stick-knob {
      position:absolute; left:50%; top:50%; width:40px; height:40px;
      border-radius:50%; background:#0af; transform:translate(-50%,-50%);
    }
    .btn {
      position:fixed; right:16px; bottom:16px; width:80px; height:80px;
      border-radius:50%; background:#fff; display:flex; align-items:center; justify-content:center;
      font-weight:bold; user-select:none;
    }
    .label {
      position:fixed; top:8px; left:50%; transform:translateX(-50%);
      color:#fff; font-family:sans-serif; font-size:18px; background:rgba(0,0,0,0.4);
      padding:6px 10px; border-radius:8px;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">
  <div class="label" id="levelLabel">Level 1 | Coins: 0</div>
  <div id="moveStick" class="stick-area"><div id="moveKnob" class="stick-knob"></div></div>
  <div id="jumpBtn" class="btn">Jump</div>
</div>

<script>
const canvas=document.getElementById("game"),ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;canvas.height=window.innerHeight;

const TILE=32;

// Tile codes:
// 0 = empty
// 1 = ground/solid
// 2 = hazard (spikes/lava)
// 4 = goal
// 5 = bounce pad (launch up)
// 6 = breakable block
// 8 = locked door (needs key)
// Key is an item, not a tile: stored in level.items with type:"key"

let coinTotal=0;
let playerColor="#ffd166";
let hasKey=false;

const makeRow=(fill=0)=>Array(32).fill(fill);

// Helper to place a horizontal segment of tile type
function place(tiles,y,xStart,xEnd,type){ for(let x=xStart;x<=xEnd;x++) tiles[y][x]=type; }

// Base ground line with goal at given x
function baseLevel(goalX){
  const tiles=Array.from({length:16},(_,y)=>makeRow(0));
  place(tiles,15,0,31,1);
  tiles[15][goalX]=4;
  return tiles;
}

// Moving platform definition: {x,y,w,h,vx,vy,minX,maxX,minY,maxY}
function makePlatform(x,y,w,h,vx,vy,bounds){ return {x,y,w,h,vx,vy,...bounds}; }

// Enemy types:
// patrol: {type:"patrol", x,y,w,h, dir, minX, maxX, speed}
// fly:    {type:"fly", x,y,w,h, t, ampX, ampY, baseX, baseY, speed}
// chase:  {type:"chase", x,y,w,h, speed, range}

const levels=[];

// Level 1: Intro
levels.push({
  name:"Level 1 - Intro",
  tiles:baseLevel(30),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:200,y:400,collected:false}],
  items:[],
  platforms:[],
  enemies:[],
  dark:false
});

// Level 2: Platforms
levels.push({
  name:"Level 2 - Platforms",
  tiles:(()=>{
    const t=baseLevel(28);
    place(t,13,10,10,1); place(t,13,14,14,1); place(t,13,18,18,1);
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:300,y:350,collected:false},{x:500,y:350,collected:false}],
  items:[],
  platforms:[
    makePlatform(12*TILE,12*TILE, TILE, TILE, 60,0, {minX:10*TILE,maxX:20*TILE})
  ],
  enemies:[{type:"patrol",x:400,y:450,w:24,h:28,dir:1,minX:320,maxX:560,speed:60}],
  dark:false
});

// Level 3: Hazards
levels.push({
  name:"Level 3 - Hazards",
  tiles:(()=>{
    const t=baseLevel(25);
    place(t,14,5,6,2);
    place(t,13,12,20,1);
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:200,y:300,collected:false}],
  items:[],
  platforms:[],
  enemies:[{type:"patrol",x:350,y:450,w:24,h:28,dir:-1,minX:300,maxX:580,speed:70}],
  dark:false
});

// Level 4: Vertical climb
levels.push({
  name:"Level 4 - Vertical",
  tiles:(()=>{
    const t=Array.from({length:16},(_,y)=>makeRow(0));
    place(t,15,0,31,1);
    t[5][30]=4; // goal at top right
    t[10][15]=1; t[8][22]=1; t[6][26]=1;
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:600,y:200,collected:false}],
  items:[],
  platforms:[
    makePlatform(16*TILE,11*TILE,TILE,TILE, 0,-40, {minY:9*TILE,maxY:12*TILE})
  ],
  enemies:[{type:"fly",x:450,y:380,w:22,h:22,t:0,ampX:60,ampY:20,baseX:450,baseY:380,speed:2}],
  dark:false
});

// Level 5: Bounce pads
levels.push({
  name:"Level 5 - Bounce",
  tiles:(()=>{
    const t=baseLevel(27);
    t[14][8]=5; t[14][16]=5; t[14][22]=5; // bounce pads
    place(t,13,10,18,1);
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:350,y:320,collected:false},{x:520,y:280,collected:false}],
  items:[],
  platforms:[],
  enemies:[{type:"patrol",x:300,y:450,w:24,h:28,dir:1,minX:280,maxX:620,speed:80}],
  dark:false
});

// Level 6: Breakable blocks over lava
levels.push({
  name:"Level 6 - Crumble",
  tiles:(()=>{
    const t=baseLevel(29);
    place(t,14,11,20,2); // lava
    for(let x=12;x<=19;x++) t[13][x]=6; // breakable
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:480,y:350,collected:false}],
  items:[],
  platforms:[],
  enemies:[],
  dark:false
});

// Level 7: Key + door
levels.push({
  name:"Level 7 - Locked",
  tiles:(()=>{
    const t=baseLevel(30);
    t[15][30]=1; // remove goal from ground
    t[10][25]=8; // locked door
    t[10][26]=4; // goal behind door
    place(t,13,12,18,1);
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:380,y:350,collected:false}],
  items:[{type:"key",x:14*TILE,y:12*TILE,collected:false}],
  platforms:[],
  enemies:[{type:"patrol",x:420,y:450,w:24,h:28,dir:1,minX:380,maxX:600,speed:70}],
  dark:false
});

// Level 8: Darkness + timing hazards
levels.push({
  name:"Level 8 - Dark Cavern",
  tiles:(()=>{
    const t=baseLevel(28);
    place(t,14,6,6,2); place(t,14,10,10,2); place(t,14,14,14,2);
    place(t,13,18,22,1);
    return t;
  })(),
  start:{x:TILE*2,y:(15*TILE)-28},
  coins:[{x:520,y:340,collected:false},{x:600,y:320,collected:false}],
  items:[],
  platforms:[makePlatform(20*TILE,12*TILE,TILE,TILE, 50,0, {minX:18*TILE,maxX:24*TILE})],
  enemies:[{type:"chase",x:500,y:450,w:24,h:28,speed:70,range:200}],
  dark:true
});

// Auto-generate additional levels with increasing complexity
for(let i=9;i<=22;i++){
  const name = "Level "+i+" - " + (i%4===1?"Gauntlet":i%4===2?"Ascend":i%4===3?"Labyrinth":"Onslaught");
  const tiles = baseLevel(i%2===0?26:29);
  // Add hazards
  if(i%3===0){ place(tiles,14,6,10,2); }
  // Add platforms
  if(i%2===0){ place(tiles,12,12,18,1); }
  // Add bounce pad occasionally
  if(i%5===0){ tiles[14][20]=5; }
  // Add breakables occasionally
  if(i%4===0){ for(let x=22;x<=25;x++) tiles[13][x]=6; }
  const coins = [
    {x:240,y:360,collected:false},
    {x:420,y:320,collected:false},
    {x:620,y:340,collected:false}
  ];
  const items = (i%6===0)?[{type:"key",x:13*TILE,y:12*TILE,collected:false}]:[];
  const platforms = [];
  if(i%2===1) platforms.push(makePlatform(16*TILE,11*TILE,TILE,TILE, 0,-40, {minY:9*TILE,maxY:12*TILE}));
  if(i%7===0) platforms.push(makePlatform(20*TILE,12*TILE,TILE,TILE, 50,0, {minX:18*TILE,maxX:24*TILE}));

  const enemies=[];
  enemies.push({type:"patrol",x:340,y:450,w:24,h:28,dir:1,minX:300,maxX:620,speed:60+5*i});
  if(i%3===1) enemies.push({type:"fly",x:480,y:360,w:22,h:22,t:0,ampX:40,ampY:25,baseX:480,baseY:360,speed:2});
  if(i%5===2) enemies.push({type:"chase",x:520,y:450,w:24,h:28,speed:80,range:220});

  levels.push({name,tiles,start:{x:TILE*2,y:(15*TILE)-28},coins,items,platforms,enemies,dark:(i%8===0)});
}

let levelIndex=0;
const player={x:0,y:0,w:24,h:28,vx:0,vy:0,onGround:false};
function loadLevel(i){
  levelIndex=i%levels.length;
  hasKey=false;
  document.getElementById("levelLabel").textContent=levels[levelIndex].name+" | Coins: "+coinTotal;
  player.x=levels[levelIndex].start.x;
  player.y=levels[levelIndex].start.y;
  player.vx=player.vy=0;
  // Reset coins/items collected state per level load? Keep coins persistent within level once collected:
  // do not reset coin/item collection on reload of same level
}

function tileAt(px,py){
  const L=levels[levelIndex];
  const tx=Math.floor(px/TILE),ty=Math.floor(py/TILE);
  if(tx<0||ty<0||tx>=32||ty>=16)return 0;
  return L.tiles[ty][tx];
}

const keys={};
window.addEventListener("keydown",e=>keys[e.code]=true);
window.addEventListener("keyup",e=>keys[e.code]=false);

// Touch joystick
let moveVec={x:0};
(function setupStick(){
  const area=document.getElementById('moveStick'),knob=document.getElementById('moveKnob');
  let active=false,startX=0;
  area.addEventListener('touchstart',e=>{active=true;startX=e.touches[0].clientX;});
  area.addEventListener('touchmove',e=>{
    if(!active)return;
    const dx=e.touches[0].clientX-startX;
    const radius=area.clientWidth/2-20;
    const nx=Math.max(-radius,Math.min(radius,dx));
    knob.style.left=`calc(50% + ${nx}px)`;
    moveVec.x=nx/radius;
  });
  area.addEventListener('touchend',()=>{active=false;moveVec.x=0;knob.style.left='50%';});
})();

// Jump button
document.getElementById('jumpBtn').addEventListener('touchstart',()=>{
  if(player.onGround){player.vy=-500;player.onGround=false;}
});

function solidAt(px,py){
  const t=tileAt(px,py);
  return t===1 || t===4 || t===6 || t===8 || t===5; // treat bounce, breakable, door, goal as solid for landing
}

function update(dt){
  const L=levels[levelIndex];

  // input
  const left=keys["ArrowLeft"]||moveVec.x<-0.2;
  const right=keys["ArrowRight"]||moveVec.x>0.2;
  if(left&&!right) player.vx=-200;
  else if(right&&!left) player.vx=200;
  else player.vx=0;
  if(keys["Space"]&&player.onGround){player.vy=-500;player.onGround=false;}

  // physics
  player.vy+=1000*dt;
  player.x+=player.vx*dt;
  player.y+=player.vy*dt;

  // Platforms movement
  for(const p of L.platforms){
    if(p.vx){ p.x+=p.vx*dt; if(p.minX!==undefined && p.maxX!==undefined){ if(p.x<p.minX){p.x=p.minX;p.vx*=-1;} if(p.x>p.maxX){p.x=p.maxX;p.vx*=-1;} } }
    if(p.vy){ p.y+=p.vy*dt; if(p.minY!==undefined && p.maxY!==undefined){ if(p.y<p.minY){p.y=p.minY;p.vy*=-1;} if(p.y>p.maxY){p.y=p.maxY;p.vy*=-1;} } }
  }

  // collision with tiles (simple ground check using foot)
  const footX=player.x+player.w/2,footY=player.y+player.h;
  const t=tileAt(footX,footY);

  // Land on solid tiles
  if(solidAt(footX,footY)){
    player.y=Math.floor(footY/TILE)*TILE-player.h;
    player.vy=0;player.onGround=true;
  } else {
    player.onGround=false;
  }

  // Special tiles actions
  if(t===4){ // goal
    loadLevel(levelIndex+1);
    return;
  }
  if(t===2){ // hazard
    loadLevel(levelIndex); // respawn
    return;
  }
  if(t===5){ // bounce pad
    player.vy=-800; player.onGround=false;
  }
  if(t===6){ // breakable block
    const ty=Math.floor(footY/TILE),tx=Math.floor(footX/TILE);
    L.tiles[ty][tx]=0; // crumble
    player.onGround=false;
  }
  if(t===8){ // door
    if(hasKey){
      // allow pass-through by temporarily treating as empty
      // shift player slightly up to prevent sticking
      player.y-=2;
    } else {
      // block movement
      player.vy=0; player.onGround=true;
    }
  }

  // Coin collection (AABB point pickup using player's rect)
  for(const c of L.coins){
    if(!c.collected &&
       player.x< c.x && player.x+player.w>c.x &&
       player.y< c.y && player.y+player.h>c.y){
      c.collected=true;
      coinTotal++;
      document.getElementById("levelLabel").textContent=L.name+" | Coins: "+coinTotal;
    }
  }

  // Key pickup
  for(const it of L.items){
    if(it.type==="key" && !it.collected &&
       player.x< it.x && player.x+player.w>it.x &&
       player.y< it.y && player.y+player.h>it.y){
      it.collected=true; hasKey=true;
    }
  }

  // Player-platform landing (AABB)
  for(const p of L.platforms){
    const px=p.x,py=p.y,pw=p.w,ph=p.h;
    const landed = player.vy>=0 &&
      player.x+player.w>px && player.x<px+pw &&
      player.y+player.h>py && player.y+player.h<py+ph+10;
    if(landed){
      player.y=py-player.h;
      player.vy=0; player.onGround=true;
      // carry player with platform
      if(p.vx) player.x+=p.vx*dt;
      if(p.vy) player.y+=p.vy*dt;
    }
  }

  // Enemies update + collisions
  for(const e of L.enemies){
    if(e.type==="patrol"){
      e.x+=e.dir*e.speed*dt;
      if(e.x<e.minX){e.x=e.minX;e.dir*=-1;}
      if(e.x+e.w>e.maxX){e.x=e.maxX-e.w;e.dir*=-1;}
    } else if(e.type==="fly"){
      e.t+=(e.speed*dt);
      e.x=e.baseX+Math.sin(e.t)*e.ampX;
      e.y=e.baseY+Math.cos(e.t*0.9)*e.ampY;
    } else if(e.type==="chase"){
      const dx=(player.x-e.x);
      const dist=Math.abs(dx);
      if(dist<e.range){
        e.x+=Math.sign(dx)*e.speed*dt;
      }
    }
    // collision with player
    if(player.x<e.x+e.w && player.x+player.w>e.x &&
       player.y<e.y+e.h && player.y+player.h>e.y){
      loadLevel(levelIndex); // hit -> respawn
      return;
    }
  }
}

function draw(){
  const L=levels[levelIndex];
  ctx.fillStyle="#222";ctx.fillRect(0,0,canvas.width,canvas.height);

  // Tiles
  for(let y=0;y<16;y++){
    for(let x=0;x<32;x++){
      const t=L.tiles[y][x]; if(!t)continue;
      const px=x*TILE,py=y*TILE;
      if(t===1){ctx.fillStyle="#555";ctx.fillRect(px,py,TILE,TILE);} // ground
      if(t===2){ctx.fillStyle=(Math.floor(Date.now()/200)%2?"#b71c1c":"#ff7043");ctx.fillRect(px,py,TILE,TILE);} // hazard
      if(t===4){ctx.fillStyle="#1e88e5";ctx.fillRect(px,py,TILE,TILE);} // goal
      if(t===5){ctx.fillStyle="#7cb342";ctx.fillRect(px,py,TILE,TILE);} // bounce
      if(t===6){ctx.fillStyle="#8d6e63";ctx.fillRect(px,py,TILE,TILE);} // breakable
      if(t===8){ctx.fillStyle=hasKey?"#4caf50":"#6d4c41";ctx.fillRect(px,py,TILE,TILE);} // door
    }
  }

  // Platforms
  for(const p of L.platforms){
    ctx.fillStyle="#90a4ae";
    ctx.fillRect(p.x,p.y,p.w,p.h);
  }

  // Coins
  for(const c of L.coins){
    if(!c.collected){
      ctx.fillStyle="#ffd700";
      ctx.beginPath();
      ctx.arc(c.x,c.y,10,0,Math.PI*2);
      ctx.fill();
    }
  }

  // Items (keys)
  for(const it of L.items){
    if(it.type==="key" && !it.collected){
      ctx.fillStyle="#cddc39";
      ctx.fillRect(it.x-6,it.y-6,12,12);
    }
  }

  // Enemies
  for(const e of L.enemies){
    ctx.fillStyle= e.type==="fly" ? "#ff8a65" : e.type==="chase" ? "#f44336" : "#ff4444";
    ctx.fillRect(e.x,e.y,e.w,e.h);
  }

  // Player
  ctx.fillStyle=playerColor;
  ctx.fillRect(player.x,player.y,player.w,player.h);

  // Darkness overlay
  if(L.dark){
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.85)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // spotlight around player
    const radius=120;
    const cx=player.x+player.w/2,cy=player.y+player.h/2;
    const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,radius);
    grad.addColorStop(0,"rgba(0,0,0,0)");
    grad.addColorStop(1,"rgba(0,0,0,0.85)");
    ctx.globalCompositeOperation="destination-out";
    ctx.fillStyle=grad;
    ctx.beginPath();
    ctx.arc(cx,cy,radius,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

let last=performance.now();
function loop(now){
  const dt=(now-last)/1000;last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Resize handling
window.addEventListener('resize',()=>{
  canvas.width=window.innerWidth;canvas.height=window.innerHeight;
});

// Shopless color change via keyboard (optional): 1..4 change player color
window.addEventListener('keydown',e=>{
  if(e.code==="Digit1") playerColor="#ffd166";
  if(e.code==="Digit2") playerColor="#ff0000";
  if(e.code==="Digit3") playerColor="#00ff00";
  if(e.code==="Digit4") playerColor="#0000ff";
});
</script>
</body>
</html>
